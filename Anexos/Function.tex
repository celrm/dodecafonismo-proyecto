	\chapter{Generador de funciones E-inducidas}
	\label{app:function}
%    \includepdf[pages=-]{Anexos/Hexa.pdf}

	\lstset{
		tabsize=3,
		language=haskell,
		frame=lines,
		numbers=left,
		identifierstyle=\color{black},
%		
%		numberstyle=\tiny,
		numberstyle=\ttfamily\tiny\color[gray]{0.3},		
%		basicstyle=\footnotesize,
		basicstyle=\small\sffamily,
%		keywordstyle=\color[rgb]{0,0,1},
		keywordstyle=\bfseries\rmfamily,
%		commentstyle=\color[rgb]{0.09, 0.45, 0.27},
		commentstyle=\it,
%		stringstyle=\color{red}
		stringstyle=\mdseries\rmfamily,
%		
		xleftmargin=2pt,
		stepnumber=1,
		numbersep=5pt,
		belowcaptionskip=\bigskipamount,
		captionpos=b,
		escapeinside={*'}{'*},
		emphstyle={\bf},
		showspaces=false,
		columns=flexible,
		showstringspaces=false,
	}
	
	\newpage
	\begin{lstlisting}
	import Control.Monad (forever, guard)
	import Data.List
	import Data.Ord (comparing)
	
	type Scale = [Int]
	
	
	-- Es la longitud de la escala cromatica: el cardinal del dominio.
	long :: Int
	long = 12
	
	
	main :: IO String
	main
		= forever
		$ do
			scale <- getLine
			putStrLn
				"Calculando...\n"
			showResult
				$ nub
				$ induce
				$ readScale
					scale
			putStrLn
				"\nTerminado."
	
	
	-- TODO instance Read
	readScale :: String -> Scale
	readScale scale
		= (\x -> if length x > 12 then [] else x)
		$ map
			(flip mod long . fst . head)
		$ filter 
			(not . null)
		$ map reads
		$ words
			scale
	
	
	-- TODO instance Show
	-- Mostrar una escala.
	showScale :: Scale -> String
	showScale scale
		= drop 1  -- Quita el primer espacio.
		$ foldl
			(\acc i ->
				acc
				++ " "
				++ show i
				-- Deja doble hueco en los numeros de una cifra.
				++ if i >= 0 && i < 10
						then " "
						else ""
			) "" scale
	
	
	-- Mostrar varias escalas.
	showScales :: [Scale] -> String
	showScales scales
		= drop 1
		$ foldl
			(\acc sc ->
				acc
				++ "\n"
				++ showScale sc
			) "" scales
	
	
	-- Mostrar el resultado del calculo.
	showResult :: [Scale] -> IO ()
	-- `best` requiere no vacio. Si ponemos la restriccion en `best`, entonces falla `head` aqui.
	showResult []
		= return ()
	
	showResult scales
		= do
			putStrLn
				$ showScale [ 0 .. (long - 1) ]
			putStrLn
				$ replicate (long * 3 - 1) '―'
			putStrLn
				$ showScales scales
			putStrLn
				$ "\nMayor ajuste ("
				++ show bestPunct
				++ "):"
			putStrLn
				$ showScales bestFits
			putStrLn
				"\nLa mas grave es:"
			putStrLn
				$ showScale
				$ head
				$ sort
					bestFits
		where
			(bestFits, bestPunct) =
				best scales
	
	
	best :: [Scale] -> ([Scale],Int)
	best scales
		= ( map fst solution
			, head $ map snd solution
			)
		where
			solution
				= head  -- El primer grupo con la minima distancia.
				$ groupBy
					(\x y -> snd x == snd y)
				$ sortBy
					(comparing snd)  -- La menor distancia.
				$ map
					(\e ->
						(e, sum  -- La suma de las distancias
							$ map  -- entre la funcion y la escala cromatica.
							(\(x, i) -> abs (x-i))
							$ zip e [0..]
						)
					)
				scales
	
	
	-- Llama a la funcioó recursiva de fixed points.
	induce :: Scale -> [Scale]
	induce scale =
		fxp (length scale) scale []
	
	
	-- Obliga a que haya alguna fixed.
	-- ¿Existe alguna solucion que no tenga 1 fixed pero si 0?
	-- He puesto demasiados head fixed, supongamos que no.
	fxp :: Int -> Scale -> [Scale] -> [Scale]
	-- Si encontro solucion, devuelvelo.
	fxp _ _ xxs@(_:_)
		= xxs
	-- Si 0 fixed points, no hay solucion.
	fxp 0 _ _
		= []
	-- Si quedan fixed points, llama a func y disminuye nfixed.
	fxp nfixed scale _
		= fxp (nfixed - 1) scale (func nfixed scale)
	
	-- TODO importarlo de sitio existente
	-- #26 de H-99
	combinations :: Int -> [a] -> [[a]]
	combinations 0 _
		= [[]]
	combinations _ []
		= []
	combinations n (x:xs)
		= map
			(x:)
			(combinations (n-1) xs)
			++ combinations n xs
	
	
	dissonances :: Scale -> [Scale]
	dissonances scale
		= combinations q scale
		where
			e = length scale
			q = e - mod long e
	
	
	-- q es el tamaño del subconjunto de frecuencias menores.
	-- c es la frecuencia menor.
	-- long = qc + (e - q)(c + 1)
	func :: Int -> Scale -> [Scale]
	func nfixed scale
		= let e = length scale
			c = div long e
		in do
			fixed <-
				combinations nfixed scale
			minFreq <-
				dissonances scale
			start <-  --[[h], [h,h], [h,h,h]]
				let
				h = head fixed
				hFreq =
					if h `elem` minFreq
						then c
						else c + 1
				in
				take hFreq $ iterate (++ [h]) [h]
			-- Quito los que tienen el 2o fixed dentro del ambito del 1o.
			guard
				(length fixed == 1
				|| (fixed !! 1) - (head fixed) >= length start)
			result <-
				let
				h = head fixed
				( (first, freqFirst) : oldFreqs )
					= map
						(\ha ->
							if ha `elem` minFreq
							then (ha, c)
							else (ha, c + 1)
						)
						$ take e
						$ dropWhile (< h)
						$ cycle
							scale
				freqs  -- Ponemos el h al final con su frecuencia ya restada.
					= oldFreqs
						++ if freqFirst /= length start
							then [ (first, freqFirst - length start) ]
							else []
				newfixed
					= take (nfixed - 1)
					$ dropWhile (<= h)
					$ cycle
					fixed
				in return $ oneCase newfixed freqs start
			guard
				(length result == long) -- Quito los que no tengan long (los []).
			return $ normalize result
	
	-- Pongo el indice 0 otra vez al principio
	-- y lo pongo en orden creciente.
	normalize :: Scale -> Scale
	normalize []
		= []
	normalize result@(h:_)
		=  map (\i -> if i >  h then i - long else i) before
			++ hh
			++ map (\i -> if i <= h then i + long else i) after
		where
			(hhafter, before)
				= splitAt (long - h) result
			(hh, after)
				= span (== h) hhafter
	
	
	-- Dados los puntos fijos, las frecuencias y el resultado
	oneCase :: Scale -> [(Int, Int)] -> Scale -> Scale
	oneCase _ _ []
		= []  -- Si no hay start ha habido un problema. No puede ocurrir.
	oneCase _ [] x
		= x   -- Si no quedan frecuencias, hemos acabado bien.
	oneCase [] ((next, nextFreq):freqs) start
		=     -- Si no quedan fixed points, simplemente rellenar.
		oneCase
		[]
		freqs $
		start ++ replicate nextFreq next
	
	-- Si quedan fixed points:
	oneCase ffixed@(f:fixed) ((next, nextFreq):freqs) start@(s:_)
	-- Si f es igual al siguiente indice, next tiene que ser ese indice porque f es fijo.
		| f==currentIndex && f==next
			= oneCase
				fixed  -- Ya hemos usado f; lo desechamos.
				((eraseFreq next nextFreq) ++ freqs) $
				start ++ [next]
		--Si no necesito fijar, entonces next no puede pasarse del siguiente fixed point f.
		| f/=currentIndex && f>=next
			= oneCase
				ffixed
				((eraseFreq next nextFreq) ++ freqs) $
				start ++ [next]
		| otherwise = []
		where
			currentIndex
				= s + length start
			eraseFreq element freq
				= if freq == 1
					then []
					else [(element, freq-1)]	

	\end{lstlisting}